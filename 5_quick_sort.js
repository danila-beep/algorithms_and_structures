const array = [4, 12, 3, 2, 5, 1, 6];
let count = 0;

function quickSort(array) {
    //базовый случай предотвращающий возможность бесконечного перевызова рекурсии
    if (array.length <= 1) {
        return array
    }

    //индекс среднего элемента массива
    let pivotIndex = Math.floor(array.length / 2)
    //средний элемент массива
    let pivot = array[pivotIndex]
    //переменная с массивом меньшей части сортируемого массива
    let less = []
    //переменная с массивом большей части сортируемого массива
    let greater = []

    //проходимся циклом по длинне массива
    for (let i = 0; i < array.length; i++) {
        count += 1

        //если итрерируемое значние равно индексу среднего элемента продолжаем без изменений
        if (i === pivotIndex) {
            continue
        }
        //если элемент массива текущей итерации меньше чем средний элемент массива, то пушим его в массив с меньшими элементами
        if (array[i] < pivot) {
            less.push(array[i])
        }
        //если элемент массива текущей итерации больше чем средний элемент массива, то пушим его в массив с большими элементами

        if (array[i] > pivot) {
            greater.push(array[i])
        }
    }

    //рекурсивно вызываем функцию сортировки и собираем новый массив в который 
    //в начало разворачиваем сортированные элементы меньшей части
    //в середену разворачиваем значение среднего элемента массива
    //в конец разворачиваем сортированные элементы большей части
    return [...quickSort(less), pivot, ...quickSort(greater)]
}

console.log("Длинна массива =", array.length);
//сложность этого алгоритма ровно O(log2n*n)
console.log(quickSort(array));
console.log("count of iterations =", count);
